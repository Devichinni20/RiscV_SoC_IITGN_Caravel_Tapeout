# POR Concepts and Design Rationale

## Purpose of This Document

This document addresses common misconceptions related to:
- Behavioral vs structural RTL
- Synthesizability
- Reset architecture
- POR modeling vs real silicon behavior

---

## Behavioral vs Structural vs Synthesizable RTL

A common misconception is that **only structural RTL is synthesizable**.

This is incorrect.

### Synthesizable RTL Includes:
- Clocked behavioral logic (`always @(posedge clk)`)
- Combinational behavioral logic (`always @(*)`)
- Structural (gate-level) RTL

### Non-Synthesizable RTL Includes:
- Time delays (`#`)
- Power-up assumptions
- Analog behavior described in digital RTL

The issue with `dummy_por` is **not that it is behavioral**,
but that it describes **time-based behavior without hardware**.

---

## Why Behavioral POR Is Fake Hardware

Simulation allows constructs such as:

```verilog
#100 porb_h = 1;
```
# Power-On Reset (POR) and Synthesizable RTL â€“ Design Rationale

## 1. RTL Coding Styles and Hardware Mapping

RTL can be written in multiple styles. All of the following map cleanly to real silicon hardware when used correctly.

### 1.1 Sequential (Behavioral) Logic

Describes flip-flops and sequential logic.

```verilog
always @(posedge clk or negedge rst_n)
```

### 1.2 Combinational Behavioral Logic

Describes combinational logic such as muxes, encoders, and decoders.
```bash
always @(*)
```

### 1.3 Structural (Gate-Level) RTL

-Explicit instantiation of logic gates and standard cells.

-All three styles are fully synthesizable as long as they describe real hardware.

### 2. Non-Synthesizable RTL Constructs

The following constructs do not represent real hardware:

-Time delays (#)

-Power-up assumptions

-Analog behavior described using digital RTL

These constructs exist only in simulation and are removed during synthesis.
---

### 3. Why dummy_por Is Not Synthesizable

The issue with dummy_por is not that it is behavioral.

The issue is that it:

-Describes time-based behavior

-Assumes reset sequencing based on simulation time

-Does not correspond to any physical hardware

As a result, dummy_por cannot be synthesized into real silicon.

### 4. Why Behavioral POR Is Fake Hardware

RTL simulation allows constructs such as:
```
#100 porb_h = 1;

```
This instructs the simulator to wait for time before releasing reset.

### 4.1 Real Silicon Reality

Real silicon:

-Has no concept of waiting for time

-Cannot delay signals unless explicit hardware exists

-Requires counters, analog POR macros, or power-good detectors

Since dummy_por builds none of this hardware, it models behavior that cannot physically exist.

### 5. What Happens During Synthesis

During synthesis:

1.dummy_por is removed or ignored

2.No POR hardware is generated

3.No power-aware reset circuitry exists on the chip

This creates a dangerous mismatch:

-RTL simulation assumes POR sequencing exists

-Silicon contains no such reset logic

Removing POR eliminates this mismatch.

### 6. Fan-In to Reset Trees Explained

Reset signals are distributed to many flip-flops across the SoC.
This distribution network is called a reset tree.

### Key Observations

POR-related signals such as:

*porb_h

*porb_l

Do not:

-Detect power stability

-Implement analog POR behavior

-Perform any special sequencing

-They simply act as sources that feed reset trees.

Functionally, they are equivalent to an external reset pin.

### 7. Clean Reset Edge vs Power-Derived Reset

Digital flip-flops only require:

-Clean reset assertion

-Clean reset deassertion

They do not care about:

-Where the reset originated

-Whether reset was generated by POR

-Whether reset is power-derived or externally driven

As long as reset timing requirements are met, the source of reset is irrelevant.

### 8. No Logic Assumes Internal POR Timing

A complete review of the RTL confirms:

-No logic waits for POR completion

-No logic checks power stability

-No logic assumes reset release after a fixed delay

-No counters or state machines depend on POR timing

-Reset is treated everywhere as a normal digital signal.

This proves the design does not architecturally depend on POR.

### 9. Why SCL-180 Does Not Require On-Chip POR
### 9.1 Pad Behavior in SCL-180 PDK

In the SCL-180 technology:

-Input pads are powered directly by VDD

-No internal enable signal is required

-No POR-gated input path exists

-Reset pins are asynchronous

-Reset pins are available immediately after power-up

This allows reset to be asserted safely during power ramp.

### 10. Why SKY130 Required POR (Technology Contrast)

In SKY130:

-Pad behavior during power-up was not guaranteed

-Internal enables and pull devices could be undefined

-Reset pins were unreliable during early power ramp

On-chip POR was required to mask these uncertainties and delay reset release until power stabilized.

### 11. Final Design Rationale

Removing on-chip POR in SCL-180 is not an optimization.
It is a correctness fix.

An external reset-only strategy:

-Matches real silicon behavior

-Eliminates simulation-only assumptions

-Simplifies reset architecture

-Aligns with industry-standard SoC design practices

This decision is validated through:

-RTL analysis

-DC_TOPO synthesis

-VCS gate-level simulation

### 12. Final Conclusion

-Behavioral POR is not real hardware.
-SCL-180 pads do not require POR.

-A single external reset pin is sufficient, safe, and correct.

Removing POR ensures consistent behavior across:

-RTL simulation

-Gate-level simulation

-Real silicon









